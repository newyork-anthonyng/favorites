-Template--

Date:
Symptom:
Cause:
How found:
Fix:
Lessons:

Credit to Henrik Warne's Blog
https://henrikwarne.com/2016/04/28/learning-from-your-bugs

Date: April 30, 2016

Symptom: Unable to upload a file into AWS. An error was getting returned, saying that there was no 'PUT' method on the '/' route.

Cause: There was no information being returned from getting a signedRequest for S3. The uploadFile method was using an undefined URL to upload its file, using a 'PUT' method. Because there was no URL, it was hitting the '/' route as a default.

How found: There was a console.log error that there was no 'PUT' method on the '/' route. This console log was from the jquery.js file.

Fix: I needed to add all of the AWS keys onto Heroku.

Lessons: Add descriptive console.log messages when in development! This would have saved me a lot of time and frustration. Also when submitting to Heroku, remember what other things you have to do. There were times when I left the server as listening to a generic port (3000 or 8000), when I should've added 'process.env.PORT' in there as well.

**********

Date: April 30, 2016

Symptom: Frontend code was running on Desktop, but not on mobile.

Cause: Strict mode doesn't work on mobile.

How found: I was running front end code that had 'use strict' in it. The code didn't run on Safari in general.

Fix: I removed the 'use strict' from the front end code.

Lessons: Do not use strict mode in front end code.

***********

Date: May 6, 2016

Symptom: A ui-view from ui-router wasn't getting loaded.

Cause: ng-app wasn't set inside of HTML or body.

How found: I had put ng-app inside of a div, and then had the ui-view outside of it. This angular app was rather small, so it only took 5 minutes to figure out what the problem was.

Fix: Include ng-app inside of the body.

Lessons: If I'm goign to be putting ng-app into a scope of a div, and not the entire HTML or body, then be wary! When angular code isn't running, start from step one and see if ng-app is even getting included.

***********

Date: May 11, 2016

Symptom: Input[type="file"] wouldn't open on $('input').click();

Cause: Browsers need a click or keypress to activate an Input[type="file"], for security concerns.

How found: This was found when experimenting with keyboard shortcuts, and trying to activate a click event on an Input[type="file"]. When attaching other click event listeners to the Input[type="file"], they would all fire. But the file dialog box never opened. It only opened when I physically clicked on the button.

Fix: There was no fix. Luckily, I was getting a keyboard shortcut to generate the $('input').click() method, so that the Input[type="file"] was properly receiving the click event.

Lessons: When testing browser stuff, start with the simplest version of what you're looking at. I wasted too much time by getting too complicated and making assumptions. After I found out what the problem was, a simple google search brought me to the issue about the security.

**********

Date: May 12, 2016

Symptom: An if-statement wasn't getting entered into, even though the condition should have been true.

Cause: The innerText property of an html node includes whitespace, and messes up == and === string comparison.

How found: I had a condition inside if-statement that checked if a type was not undefined, and if its text was equal to "Bookmarks".
if(typeof $nextForm !== undefined && $nextForm.innerText === 'Bookmarks')
The .innerText property included white space inside the string, and I didn't notice it in the console.logs.

Fix: Use textContent, or $().text().

Lessons: There are differences between innerText, textContent, and html. Be careful.

**********

Date: June 1, 2016

Symptom: Couldn't test the success method chained from a $http response.

Cause: $http wasn't meant to be tested with a success method. You either have to let your $http run as usual (set up $httpBackend and flush all requests), or set up a fully mocked up promise (with it's own success method).

How found: Karma tests were failing.

Fix: I had my service return a mocked promise, which had its own success method.
var expectedResponse = 'Expected response from $http';

_mockService = {
	success: function(fn) {
		fn(expectedResponse);
	}
};

Lessons: By using a callback inside of the _mockService.success, we are able to carry on as usual.

http://stackoverflow.com/questions/23731637/test-a-controller-with-success-and-error
